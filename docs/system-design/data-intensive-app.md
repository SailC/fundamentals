[0:04:11.0] JM: Many applications today are data-intensive rather than compute-intensive.
Explain the distinction between these two application types.
[0:04:22.9] MK: Sure. I would call an application data-intensive if data is the primary challenge
that arises when building that application. That could be, for example, the amount of data, the sheer volume of it, but it might also be the complexity of the data, how interlinked it is, or might be how fast it’s changing both in terms of the data writes, but also the structural changes.

Quite a lot of applications which fall in that category — My background is from doing data infrastructure to internet companies. I used to work at LinkedIn and the kind of architectures, they are somewhat similar at Facebook, Twitter, Google, Amazon, Microsoft, et cetera. I believe
there’s actually similar kind of data processing and data storage challenges occur in many other areas as well, which I’m less familiar with.
One area that came to mind, for example, would be scientific data. If you’re a physicist at The Large Hadron Collider, for example, I believe you might be doing a lot of data crunching in order to discover new particles. If you’re a genomics researcher trying to find a new cancer drug then maybe you would be crunching through large amounts of genome data. So I think it’s quite a
generic term data-intensive applications just because there’s so many different things that really fall under that category

[0:05:52.2] JM: We had this web 2.0 period where there were companies like LinkedIn and Twitter and these companies were getting started and they had to deal with these high volumes of data. During this period of time, we saw the creation of a lot of abstractions that make it a whole lot easier to work with some of the canonical problems of data-intensive applications.
We saw things like Kafka get developed. Obviously, AWS got its start in this period. Now, we’re in this world where we’ve got some really useful abstractions that allow us to solve some of the canonical problems. Then, if you’re Netflix, or Uber, or a company of that scale where it’s like you not only have the problems and the challenges of a Twitter or a LinkedIn, but you maybe got these new challenges where you’ve got — It’s obviously a kind of a buzz word. It doesn’t really make any sense, but the real time data challenges. They’re slightly different challenges, but they are a superset of the challenges that came before. We are in this kind of new era where not only do we have the big data stuff of web 2.0, but we have the fast data challenges of maybe web 3.0.

[0:07:13.1] MK: Yes. I don’t know exactly which version number of the web we are at right now, but I think this general idea of new challenges having risen like maybe in the last 10, 15 years or so I think is very true. I actually spent a fair amount of time in preparing this book, just going
back a bit through computing history and looking at the history of, say, relational databases which were developed in the 70s and really stayed around for a long time and were really the dominant way of data management for decades, literally. Then, suddenly, people thought of moving away from it. Then, at the moment, no SQL came up in 2005 or something like that. Really, that was not so much a movement against relational databases. It’s rather embracing a much wider range of other kind of storage and processing
technologies that’s previously been not even considered. Part of that was definitely driven by just relational databases no longer really fitting all of the different use cases, all of the different things people wanted to do with data. Although there are still super relevant relational databases. They’re still used a lot. They’re not the last work in terms of dealing with data. Since you mentioned abstractions, I think relational databases were so successful because they were a great abstraction for the kinds of data that they were designed for. The problem is that now we have things, like you mentioned, is real-time data, for example, where at least the
classic implementations of relational databases simply don’t handle that well. I feel like at the moment we’re searching for these new abstractions that we’ll see us through the next couple of decades. Right now, everything is — That there’s this explosion of many different technologies and they’re all competing for getting our attention, and it’s really hard to
get an overview sometimes or what technology is actually suitable for what purpose.

[0:09:20.6] JM: It is, because you write about this. The idea that when a new programmer starts out and you’re taking your basic data structures class and these data structures are like a queue, or a database, or a cache, and these are data structures with very clear responsibilities,
but there are these newer tools, like Redis, or Kafka, although these tools are now like a decade
old. They’re less defined in their core functionality, because they can operate as both a
message queue and a data store, or they might have these varying durability guarantees where
it’s not as easy to explain the durability, or is easy to understand the durability, the consistency
policies of them.
